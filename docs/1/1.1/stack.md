# 堆栈

- 编辑：李竹楠
- 日期：2024/02/08

## 1. 栈的应用

堆栈是算法和程序中最常用的辅助结构，其的应用十分广泛。堆栈基本应用于两个方面：

- 使用堆栈可以很方便的保存和取用信息，因此长被用作算法和程序中的辅助存储结构，临时保存信息，供后面操作中使用。例如：操作系统中的函数调用栈，浏览器中的前进、后退功能。
- 堆栈的后进先出规则，可以保证特定的存取顺序。例如：翻转一组元素的顺序、铁路列车车辆调度。

### 1.1 例题

#### 1.1.1 [有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 每个右括号都有一个对应的相同类型的左括号。
 

示例 1：

- 输入：s = "()"
- 输出：true

示例 2：

- 输入：s = "()[]{}"
- 输出：true

示例 3：

- 输入：s = "(]"
- 输出：false

``` python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if len(s) % 2 != 0:
            return False
        stack = list()
        for ch in s:
            if ch == '(' or ch == '[' or ch == '{':
                stack.append(ch)
            elif ch == ')':
                if len(stack) !=0 and stack[-1] == '(':
                    stack.pop()
                else:
                    return False
            elif ch == ']':
                if len(stack) !=0 and stack[-1] == '[':
                    stack.pop()
                else:
                    return False
            elif ch == '}':
                if len(stack) !=0 and stack[-1] == '{':
                    stack.pop()
                else:
                    return False
        if len(stack) == 0:
            return True
        else:
            return False
```

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

#### 1.1.2 [基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。

注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。
 
示例 1：

> 输入：s = "3+2*2"
> 输出：7

示例 2：

> 输入：s = " 3/2 "
> 输出：1

示例 3：

> 输入：s = " 3+5 / 2 "
> 输出：5

## 2. 单调栈

### 2.1 简介

单调栈（Monotone Stack）：一种特殊的栈。在栈的先进后出规则基础上，要求从栈顶到栈底的元素是单调递增（或者单调递减）。其中满足从栈顶到栈底的元素是单调递增的栈，叫做单调递增栈。满足从栈顶到栈底的元素是单调递减的栈，叫做单调递减栈。

**注意：这里定义的顺序是从栈顶到栈底。有的文章里是反过来的。本文全文以栈顶到栈底的顺序为基准来描述单调栈**。

#### 2.1.1 单调递增栈

单调递增栈：只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。这样就保证了：栈中保留的都是比当前入栈元素大的值，并且从栈顶到栈底的元素值是单调递增的。

单调递增栈的入栈、出栈过程如下：

- 假设当前进栈元素为 x，如果 x 比栈顶元素小，则直接入栈。
- 否则从栈顶开始遍历栈中元素，把小于 x 或者等于 x 的元素弹出栈，直到遇到一个大于 x 的元素为止，然后再把 x 压入栈中。

下面我们以数组 `[2,7,5,4,6,3,4,2]` 为例，模拟一下单调递增栈的进栈、出栈过程。具体过程如下：

|第i步|待插入元素|操作|结果（左侧为栈底）|
|---|---|---|---|
|1|2|2 push|[2]|
|2|7|2 pop, 7 push|[7]|
|3|5|5 push|[7, 5]|
|4|4|4 push|[7, 5, 4]|
|5|6|4 pop, 5 pop, 6 push|[7, 6]|
|6|3|3 push|[7, 6, 3]|
|7|4|3 pop, 4 push|[7, 6, 4]|
|8|2|2 push|[7, 5, 4, 2]|

最终栈中元素为 [7,6,4,2]。因为从栈顶（右端）到栈底（左侧）元素的顺序为 2,4,6,7，满足递增关系，所以这是一个单调递增栈。

示例代码如下：

``` python
def monotoneIncreasingStack(nums):
    stack = []
    for num in nums:
        while stack and num >= stack[-1]:
            stack.pop()
        stack.append(num)
```

#### 2.1.2 单调递减栈

同上，只是排序和过程相反。

示例代码如下：

``` python
def monotoneDecreasingStack(nums):
    stack = []
    for num in nums:
        while stack and num <= stack[-1]:
            stack.pop()
        stack.append(num)
```

### 2.2 适用场景

单调栈可以在时间复杂度为 $O(n)$ 的情况下，求解出某个元素左边或者右边第一个比它大或者小的元素。

所以单调栈一般用于解决一下几种问题：

- 寻找左侧第一个比当前元素大的元素：从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）
    - 一个元素左侧第一个比它大的元素就是将其**插入单调递增栈**时的栈顶元素。
    - 如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。
- 寻找左侧第一个比当前元素小的元素：从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）
    - 一个元素左侧第一个比它小的元素就是将其**插入单调递减栈**时的栈顶元素。
    - 如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。
- 寻找右侧第一个比当前元素大的元素。
- 寻找右侧第一个比当前元素小的元素。


### 2.3 例题

#### 2.3.1 [下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/description/)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

示例 1：

> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
> 输出：[-1,3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
    - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
    - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
    - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。

示例 2：

> 输入：nums1 = [2,4], nums2 = [1,2,3,4].
> 输出：[3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
    - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
    - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。