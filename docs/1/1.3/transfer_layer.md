# 网络层

- 作者：李竹楠
- 日期：2023/11/29

## 概述

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

该协议主要包括TCP和UDP协议。

## TCP协议

### TCP首部格式

![TCP-HEADER](../../../pics/7.png)

- 源端口号：表示发送端的端口号，字段长 16 位。
- 目的端口号：表示接收端端口号，字段长度 16 位。
- 序号：字段长 32 位。序列号是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。序列号不会从 0 开始，是在建立连接的时候由计算机随机生成一个数作为初始值，通过 SYN 包传给接收端主机。
- 确认号：长度是 32 位。是指下一次应该收到的数据的序列号。发送端收到这个确认应答以后可以认定这个序号之前的数据都已经被正常接收。
- 数据偏移：表示数据开始的地方离 TCP 起始处有多远。实际上也就是表示 TCP 首部的长度。
- 保留：该字段是为了以后扩展时使用，长度是 4 位。
- 控制位：长度为 8 位。每一位从左到右分别是URG、ACK、PSH、RST、SYN、FIN。具体我会在讲解 TCP 三次握手和四次挥手再重点说明。
- 窗口大小：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
- 校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
- 紧急指针：该字段表示本报文中紧急数据的指针。从数据部分的首位到紧急指针所指位置为止为紧急数据。
- 选项：用于提高 TCP 的传输性能，是可变长的可选信息。最多包含 40 字节。

### 面试题

1. 详细说一下 TCP 的三次握手机制

> TCP 提供面向连接的服务，在传送数据前必须建立连接，TCP 连接是通过三次握手建立的。下图是三次握手示意图
> ![TCP](../../../pics/9.jpg)
> 过程如下：
> 1. 最开始，客户端和服务端都处于 CLOSE 状态，服务端监听客户端的请求，进入 LISTEN 状态
> 2. 客户端端发送连接请求，**第一次握手** (SYN=1, seq=x)，发送完毕后，客户端就进入 SYN_SENT 状态
> 3. 服务端确认连接，**第二次握手** (SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端就进入 SYN_RCV 状态
> 4. 客户端收到服务端的确认之后，再次向服务端确认，这就是**第三次握手**(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态

2. TCP 握手为什么是三次，为什么不能是两次？不能是四次？

回答为什么是两次的时候，要先明白为什么要三次握手，还说句话说，为什么三次握手成功后才算是可靠的链路。
> **检查双方是否都具备发送和接收数据的能力**：TCP 是基于全双工的可信传输协议，也就意味着数据可以同时在两个方向上传输。在建立三次握手的过程中也就是在检验双方发送和接收数据的能力是否具备。
> - **第一次握手**：这时候客户端知道自己具备了发送数据的能力，但还不知道服务端是否有接收和发送数据的能力。
> - **第二次握手**：当服务端接收到报文后，回复确认报文，此时服务端知道客户端具有发送报文的能力，并且知道自己具有接收和发送数据的能力，但还不知道客户端是否具有接收数据的能力。
> - **第三次握手**：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，因为服务端还不知道客户端具备接收数据的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。
>
> **防止重复连接**：
> 在网络状况比较复杂或比较差的情况下，发送方可能会连续发送多次建立连接的请求。
> 如果 TCP 握手的次数只有两次，那么接收方只能选择接受请求或者拒绝连接请求，但并不清楚这次的请求是否是正常的请求。
> 如果是三次握手的话，客户端在接收到服务端 seq+1 的消息之后，通过对比，就可以判断当前连接是否是历史连接。
> 如果是的话就会发送终止报文给服务端终止连接。如果不是历史连接就发送确认报文建立连接。

上文可以得到一个小总结，1. 检验各方对数据接收发送的能力。2. 防止重复连接（同样解释了为什么不能只是两次握手）。那么只有两次还有其他问题？
> 有两个主要原因：
> - 首先，为了防止服务器端开启一些无用的连接增加服务器开销
> 由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1的第一次握手。
> 如果服务器端就直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，并且这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。
> 如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，服务器端是不知道客户端有没有接收到服务器端返回的信息的。
> 所以，造成的后果就是，服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。如下图：
> ![](../../../pics/10.jpg)
> - 另外，防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误（这个就是上文提到的**防止重复链接**）。
> ![](../../../pics/11.jpg)
> 所以我们需要“第三次握手”来确认这个过程：
> 通过第三次握手的数据告诉服务端，客户端有没有收到服务器“第二次握手”时传过去的数据，以及这个连接的序号是不是有效的。
> 若发送的这个数据是“收到且没有问题”的信息，接收后服务器就正常建立 TCP 连接，否则建立 TCP 连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。
> 为什么不是四次？
> 简单说，就是三次挥手已经足够创建可靠的连接，没有必要再多一次握手导致花费更多的时间建立连接。

3. 三次握手中每一次没收到报文会发生什么情况？

> - 第一次握手服务端未收到 SYN 报文
> 服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送 SYN 报文，如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。
> - 第二次握手客户端未收到服务端响应的 ACK 报文 
> 客户端会继续重传，直到次数限制；而服务端此时会阻塞在 accept()处，等待客户端发送 ACK 报文
> - 第三次握手服务端未收到客户端发送过来的 ACK 报文
> 服务端同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态。

在之前的开发过程中使用TCP会遇到非常多的异常，基本都与上面三种情况相关。
所以需要重新捋一下其中的逻辑。一般情况下，正常关闭是需要调用```Socket.close()```函数，经过四次挥手以及FIN标记，服务器和客户端断开连接。这是正常情况。但是往往会出现异常，比如JAVA中常见的```java.net.SocketException: Connection reset```。出现这个异常是因为TCP标记位置为了RST。这个问题就出现在服务器断开连接不接受数据，如果此时客户端还往服务器发送数据，但是发现此时Socket已经 关闭了，则会返回RST标志给客户端。
另外，还有一个常见的错误```Connection reset by peer```，虽然TCP的标记位都是RST，但是与上面的```Connection Reset```是有区别的：
- 一端退出，但退出时并未关闭该连接，另一端如果在从连接中读数据则抛出```Connection Reset```：服务器返回了RST时，如果此时客户端正在从Socket的输出流中**读数据**则会提示```Connection reset```
- 如果一端的Socket被关闭（或主动关闭，或因为异常退出而 引起的关闭），另一端仍发送数据，发送的第一个数据包引发```Connection reset by peer```：服务器返回了RST时，如果此时客户端正在往Socket的输入流中**写数据**则会提示 ```Connection reset by peer```

这类问题比较容易排查，就是一方断开连接了，可以对应上文的没收到报文的不同情况进行排查。
解决方案有以下几种：（埋坑，后续补上）

4. 第二次握手传回了 ACK，为什么还要传回 SYN？

> ACK 是为了告诉客户端传来的数据已经接收无误。
> 而传回 SYN 是为了告诉客户端，服务端响应的确实是客户端发送的报文。

5. 第 3 次握手可以携带数据吗？

> 第 3 次握手是可以携带数据的。
> 此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。
> 第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。

6. 说说半连接队列和 SYN Flood 攻击的关系？

> 首先，先说一下什么是半连接队列。TCP 进入三次握手前，服务端会从 CLOSED 状态变为 LISTEN 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。
> 顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。
> TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，即半连接队列。
> 当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。
> SYN Flood 就是针对半连接队列发起的攻击。SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造不存在的 IP 地址, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 SYN 接收队列（半连接队列），使得服务器不能为正常⽤户服务。
> ![](../../../pics/12.jpg)
> 解决方案：
> 主要有两种：1. SYN cookie 2. SYN Proxy 防火墙
> - SYN cookie：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
> - SYN Proxy 防火墙：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。

7. 说说 TCP 四次挥手的过程？
8. TCP 挥手为什么需要四次呢？
9. TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？
10. 保活计时器有什么用？
11. CLOSE-WAIT 和 TIME-WAIT 的状态和意义？
12. TIME_WAIT 状态过多会导致什么问题？怎么解决？
13. 说说 TCP 报文首部的格式？
14. TCP 是如何保证可靠性的？
15. 说说 TCP 的流量控制？
16. 详细说说 TCP 的滑动窗口？
17. 了解 Nagle 算法和延迟确认吗？
18. 说说 TCP 的拥塞控制？
19. 说说 TCP 的重传机制？
20. 说说 TCP 的粘包和拆包？

## UDP协议

### UDP首部格式

![TCP-HEADER](../../../pics/8.jpg)

